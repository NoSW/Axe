#pragma once

#include "00Core/Config.hpp"

#include <memory_resource>
#include <memory>
#include <array>
#include <atomic>

namespace axe::memory
{

// ----------------------------------------------------------------------------
// We can manage default, namely global alloc in class DefaultMemoryResource
// ---------------------------------------------------------------------------
class DefaultMemoryResource final : public std::pmr::memory_resource
{
    // For covering std::pmr::polymorphic_allocator
    virtual void* do_allocate(size_t bytes, size_t align) override;
    virtual void do_deallocate(void* ptr, size_t bytes, size_t align) override;
    virtual bool do_is_equal(const memory_resource& that) const noexcept override { return this == &that; }

    DefaultMemoryResource() noexcept;
    ~DefaultMemoryResource() noexcept;

#if AXE_CORE_MEM_DEBUG_ENABLE
private:
    std::atomic<u32> _mAllocBytes      = 0;
    std::atomic<u32> _mAllocCount      = 0;
    std::atomic<u32> _mFreeCount       = 0;
    std::atomic<u32> _mFreeNullCount   = 0;
    std::atomic<u32> _mAllocByPmrBytes = 0;
    std::atomic<u32> _mFreeByPmrBytes  = 0;
    std::atomic<u32> _mAllocByPmrCount = 0;
    std::atomic<u32> _mFreeByPmrCount  = 0;
#endif

public:
    static DefaultMemoryResource* const get() noexcept
    {
        static DefaultMemoryResource ins;
        return &ins;
    }

    // used for user-allocate
    [[nodiscard]] void* realloc(void* p, size_t newsize) noexcept;
    [[nodiscard]] void* new_n(size_t bytes);
    [[nodiscard]] void* new_nothrow(size_t bytes) noexcept;
    [[nodiscard]] void* new_aligned(size_t bytes, size_t align);
    [[nodiscard]] void* new_aligned_nothrow(size_t bytes, size_t align) noexcept;
    void free(void* p) noexcept;
    void free_size(void* p, size_t bytes) noexcept;
    void free_aligned(void* p, size_t align) noexcept;
    void free_size_aligned(void* p, size_t bytes, size_t align) noexcept;
};

// ----------------------------------------------------------------------------
// MonoMemoryResource
// ---------------------------------------------------------------------------
template <uint32_t BYTES = 4096>
class MonoMemoryResource : public std::pmr::monotonic_buffer_resource
{
    static constexpr uint32_t _MAX_BUF_SIZE = 256 * 1024;  // 256 KB
    static constexpr uint32_t _MIN_BUF_SIZE = 256;         // 256 B
    static constexpr auto _round(uint32_t n) { return n > _MAX_BUF_SIZE ? _MAX_BUF_SIZE : (n < _MIN_BUF_SIZE ? _MIN_BUF_SIZE : n); }

public:
    MonoMemoryResource(std::pmr::memory_resource* const upstream = std::pmr::get_default_resource()) noexcept
        : std::pmr::monotonic_buffer_resource(_mData, _round(BYTES), upstream)
    {
    }

private:
    uint8_t _mData[_round(BYTES)];
};

// ----------------------------------------------------------------------------
// ptr
// ---------------------------------------------------------------------------

template <typename>
class owner_ptr;

template <typename T>
class observer_ptr : public std::weak_ptr<T>
{
public:
    constexpr observer_ptr() noexcept = default;
    ~observer_ptr() noexcept          = default;

    // copy and move constructors and assignment operators are generated by compiler
private:
    // disabled member functions
    std::shared_ptr<T> lock() const noexcept = delete;

    // maker
    observer_ptr(const owner_ptr<T>& other) noexcept : std::weak_ptr<T>(other) {}

    template <typename Ty>
    friend observer_ptr<Ty> make_observer(owner_ptr<Ty>&);
};

template <typename T>
class owner_ptr : public std::shared_ptr<T>
{
public:
    constexpr owner_ptr() noexcept = default;
    ~owner_ptr() noexcept          = default;

private:
    // copy and move constructors and assignment operators are deleted
    owner_ptr(const owner_ptr<T>& other) noexcept               = delete;
    owner_ptr(owner_ptr<T>&& other) noexcept                    = delete;
    owner_ptr<T>& operator=(const owner_ptr<T>& other) noexcept = delete;
    owner_ptr<T>& operator=(owner_ptr<T>&& other) noexcept      = delete;

    // disabled member functions
    long use_count() const noexcept                             = delete;

    // maker
    owner_ptr(std::shared_ptr<T> a) noexcept : std::shared_ptr<T>(a){};

    template <typename Ty, typename... Args>
    friend owner_ptr<Ty> make_owner(Args&&...);
};

template <typename Ty, typename... Args>
[[nodiscard]] owner_ptr<Ty> make_owner(Args&&... args)
{
    return owner_ptr<Ty>(std::make_shared<Ty>(std::forward<Args>(args)...));
}

template <typename Ty>
[[nodiscard]] observer_ptr<Ty> make_observer(owner_ptr<Ty>& p)
{
    return observer_ptr<Ty>(std::forward<owner_ptr<Ty>>(p));
}

}  // namespace axe::memory